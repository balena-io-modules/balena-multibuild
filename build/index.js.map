{"version":3,"sources":["../lib/index.ts"],"names":[],"mappings":";;AAAA,oCAAoC;AAEpC,4BAA4B;AAE5B,kCAAkC;AAClC,sCAAsC;AAItC,qCAAoC;AAEpC,0CAA0C;AAC1C,uCAAwC;AAExC,iCAAiC;AAWjC,0BACC,WAAwB,EACxB,WAA4B;IAG5B,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAEtC,MAAM,KAAK,GAAG,KAAK,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAEpD,MAAM,OAAO,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAE9B,MAAM,OAAO,GAAG,CACf,MAAqB,EACrB,MAAuB,EACvB,IAAgB,EACT,EAAE;YAET,MAAM,YAAY,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,EAAE;gBAC3C,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACnB,MAAM,CAAC,KAAK,CAAC;gBACd,CAAC;gBACD,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAQ,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;YACvD,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC,CAAC;gBAC1B,MAAM,SAAS,GAAG,MAAM,CAAC;gBACzB,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;gBAEtE,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC;qBAC9B,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE;oBACb,YAAY,CAAC,WAAY,CAAC,KAAK,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;oBAChD,IAAI,EAAE,CAAC;gBACR,CAAC,CAAC;qBACD,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;oBACZ,MAAM,CAAC,IAAI,iBAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,CAAC,CAAC,CAAC;YACJ,CAAC;YAAC,IAAI,CAAC,CAAC;gBAGP,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC;qBACxB,IAAI,CAAC,GAAG,EAAE;oBACV,IAAI,EAAE,CAAC;gBACR,CAAC,CAAC;qBACD,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;oBACZ,MAAM,CAAC,IAAI,iBAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzB,CAAC,CAAC,CAAC;YACJ,CAAC;QACF,CAAC,CAAC;QAEF,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC7B,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,EAAE;YACzB,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,EAAE;gBACtB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACpB,IAAI,CAAC,WAAY,CAAC,QAAQ,EAAE,CAAC;gBAC9B,CAAC;YACF,CAAC,CAAC,CAAC;YACH,OAAO,CAAC,KAAK,CAAC,CAAC;QAChB,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,EAAE;YACzB,MAAM,CAAC,IAAI,iBAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC;AACJ,CAAC;AAhED,4CAgEC;AAED,2BACC,KAAkB,EAClB,YAAoB,EACpB,UAAkB;IAElB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,IAAe,EAAE,EAAE;QAC7C,MAAM,CAAC,qBAAW,CAAC,IAAI,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;IACrD,CAAC,CAAC,CAAC;AACH,CAAC;AARD,8CAQC","file":"index.js","sourcesContent":["import * as Promise from 'bluebird';\n// import * as Dockerode from 'dockerode';\nimport * as _ from 'lodash';\nimport * as Stream from 'stream';\nimport * as tar from 'tar-stream';\nimport * as TarUtils from 'tar-utils';\n\n// import { runBuildTask } from './build';\nimport { BuildTask } from './build-task';\nimport { TarError } from './errors';\n// import { LocalImage } from './local-image';\nimport * as PathUtils from './path-utils';\nimport { resolveTask } from './resolve';\nimport { Composition } from './types';\nimport * as Utils from './utils';\n\n/**\n * Given a composition and stream which will output a valid tar archive,\n * split this stream into it's constiuent tasks, which may be a docker build,\n * or import of external image using docker pull.\n *\n * @param composition An object representing a parsed composition\n * @param buildStream A stream which will output a valid tar archive when read\n * @return A promise which resolves to an array of build tasks\n */\nexport function splitBuildStream(\n\tcomposition: Composition,\n\tbuildStream: Stream.Readable,\n): Promise<BuildTask[]> {\n\n\treturn new Promise((resolve, reject) => {\n\t\t// Firstly create a list of BuildTasks based on the composition\n\t\tconst tasks = Utils.generateBuildTasks(composition);\n\n\t\tconst extract = tar.extract();\n\n\t\tconst entryFn = (\n\t\t\theader: tar.TarHeader,\n\t\t\tstream: Stream.Readable,\n\t\t\tnext: () => void,\n\t\t): void => {\n\t\t\t// Find the build context that this file should belong to\n\t\t\tconst matchingTask = _.find(tasks, (task) => {\n\t\t\t\tif (task.external) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn PathUtils.contains(task.context!, header.name);\n\t\t\t});\n\n\t\t\tif (matchingTask != null) {\n\t\t\t\tconst newHeader = header;\n\t\t\t\tnewHeader.name = PathUtils.resolve(matchingTask.context, header.name);\n\n\t\t\t\tTarUtils.streamToBuffer(stream)\n\t\t\t\t.then((buf) => {\n\t\t\t\t\tmatchingTask.buildStream!.entry(newHeader, buf);\n\t\t\t\t\tnext();\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\treject(new TarError(e));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// To work around bugs in tar-stream, we need to drain the input\n\t\t\t\t// stream here, and drop the output\n\t\t\t\tUtils.drainStream(stream)\n\t\t\t\t.then(() => {\n\t\t\t\t\tnext();\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\treject(new TarError(e));\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\textract.on('entry', entryFn);\n\t\textract.on('finish', () => {\n\t\t\t_.each(tasks, (task) => {\n\t\t\t\tif (!task.external) {\n\t\t\t\t\ttask.buildStream!.finalize();\n\t\t\t\t}\n\t\t\t});\n\t\t\tresolve(tasks);\n\t\t});\n\t\textract.on('error', (e) => {\n\t\t\treject(new TarError(e));\n\t\t});\n\n\t\tbuildStream.pipe(extract);\n\t});\n}\n\nexport function performResolution(\n\ttasks: BuildTask[],\n\tarchitecture: string,\n\tdeviceType: string,\n): Promise<BuildTask[]> {\n\treturn Promise.map(tasks, (task: BuildTask) => {\n\t\treturn resolveTask(task, architecture, deviceType);\n});\n}\n\n/**\n * Given a list of build tasks, and a handle to a docker daemon, this function\n * will perform the tasks and return a list of LocalImage values, which\n * represent images present on the docker daemon provided.\n *\n * @param tasks A list of build tasks to be performed\n * @param docker A handle to a docker daemon, retrieved from Dockerode\n * @return A promise which resolves to a list of LocalImages\n */\n// export function performBuilds(\n//   tasks: BuildTask[],\n//   docker: Dockerode,\n// ): Promise<LocalImage[]> {\n//   return Promise.map(tasks, (task: BuildTask) => {\n//     return runBuildTask(task, docker);\n//   });\n// }\n"],"sourceRoot":"lib"}